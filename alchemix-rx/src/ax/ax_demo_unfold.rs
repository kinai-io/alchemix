use std::{any::Any, future::Future, pin::Pin, sync::Arc};

use crate::{
    ax::{AxContext, ActionDispatcher, AxAction, AxResponse},
    ax::{ActionHandler, HandlerFunction},
    prelude::Payload,
};
use serde::Serialize;

#[derive(Debug)]
pub struct AddAction {
    pub left: u16,
    pub right: u16,
}

// Generated by macro
impl AxAction for AddAction {
    fn get_id(&self) -> &str {
        "000"
    }

    fn get_kind(&self) -> &str {
        "AddAction"
    }
}

#[derive(Debug, Serialize)]
pub struct Sum {
    pub result: u16,
}

pub async fn add_action(
    action: &AddAction,
    _dispatcher: &ActionDispatcher,
    context: &TestContext,
) -> Result<Sum, String> {
    let res = action.left + action.right;
    context.log(&format!(
        "Add: {} + {} = {}",
        action.left, action.right, res
    ));
    Ok(Sum { result: res })
}

// Generated by macro
pub fn create_add_action_handler() -> ActionHandler {
    let handler: Pin<Box<HandlerFunction>> = Box::pin(add_action_executor);
    ActionHandler::new(handler, "AddAction", "execute_add")
}

pub fn add_action_executor(
    dispatcher: &ActionDispatcher,
    value: Arc<Payload>,
) -> Pin<Box<dyn Future<Output = AxResponse> + Send + Sync + '_>> {
    let context: &TestContext = dispatcher.get_context();

    Box::pin(async move {
        // Simulate some work and return an RxResponse
        if let Ok(payload) = value.downcast::<AddAction>() {
            let p = payload.as_ref();
            let res = add_action(p, dispatcher, context).await;
            if let Ok(res) = res {
                return AxResponse {
                    success: true,
                    handler: "execute_add".to_string(),
                    value: Some(serde_json::to_value(res).unwrap()),
                };
            }
        }
        return AxResponse {
            success: false,
            handler: "execute_add".to_string(),
            value: None,
        };
    })
}

pub struct TestContext {}

impl TestContext {
    pub fn log(&self, text: &str) {
        println!("Log: {}", text);
    }
}

// Generated by macro
impl AxContext for TestContext {
    
    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_context(&self) -> &dyn AxContext {
        self
    }
}

#[tokio::test]
pub async fn test_action_unfold() {
    
    let context = TestContext {};
    let mut dispatcher = ActionDispatcher::new(context);

    
    dispatcher.add_action_handlers(vec![create_add_action_handler()]);

    
    let add_action = AddAction { left: 2, right: 3 };
    
    let res = dispatcher.trigger_action(add_action).await;

    println!("Res : {:?}", res);
    println!("Res JSON : {:?}", serde_json::to_string(&res).unwrap());
}