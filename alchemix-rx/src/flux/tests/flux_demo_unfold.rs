use crate::prelude::*;

#[entity]
pub struct AddAction {
    pub left: u16,
    pub right: u16,
}


#[entity]
pub struct Sum {
    pub result: u16,
}


pub async fn add_action(
    action: &AddAction,
    _dispatcher: &Flux,
    context: &TestContext,
) -> Result<Sum, String> {
    let res = action.left + action.right;
    context.log(&format!(
        "Add: {} + {} = {}",
        action.left, action.right, res
    ));
    Ok(Sum::new(res))
}

// Generated by macro
pub fn create_add_action_handler() -> EventHandler {
    let handler: Pin<Box<HandlerFunction>> = Box::pin(add_action_executor);
    EventHandler::new(handler, "AddAction", "execute_add")
}

// Generated by macro
pub fn add_action_executor(
    dispatcher: &Flux,
    value: Arc<Payload>,
) -> Pin<Box<dyn Future<Output = AxResponse> + Send + Sync + '_>> {
    let context: &TestContext = dispatcher.get_context();

    Box::pin(async move {
        // Simulate some work and return an RxResponse
        if let Ok(payload) = value.downcast::<AddAction>() {
            let p = payload.as_ref();
            let res = add_action(p, dispatcher, context).await;
            match res {
                Ok(res) => AxResponse::entity("execute_add", res),
                Err(message) => AxResponse::error( "execute_add", &message)
            }
        }else {
            AxResponse::error( "execute_add", "Action downcast error")
        }
        
    })
}

pub struct TestContext {}

impl TestContext {
    pub fn log(&self, text: &str) {
        println!("Log: {}", text);
    }
}

#[async_trait]
// Generated by macro
impl FluxContext for TestContext {
    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_context(&self) -> &dyn FluxContext {
        self
    }

    async fn json_event(&self, dispatcher: &Flux, event: &Value) -> Vec<AxResponse> {
        if let Ok(action) = serde_json::from_value::<Sum>(event.clone()) {
            return dispatcher.dispatch_event(action).await;
        }
        vec![]
    }

    fn get_hooks(&self) -> Vec<EventHandler> {
        vec![]
    }
}

#[tokio::test]
pub async fn test_action_unfold() {
    let context = TestContext {};
    let mut dispatcher = Flux::new(context);

    dispatcher.add_action_handlers(vec![create_add_action_handler()]);

    let add_action = AddAction::new(2, 3);

    let res = dispatcher.dispatch_event(add_action).await;

    println!("Res : {:?}", res);
    println!("Res JSON : {:?}", serde_json::to_string(&res).unwrap());
}
