use crate::prelude::*;

#[entity]
pub struct AddAction {
    pub left: u16,
    pub right: u16,
}


#[entity]
pub struct Sum {
    pub result: u16,
}


pub async fn add_action(
    action: &AddAction,
    _state: &FluxState,
    context: &TestContext,
) -> HookResponse {
    let res = action.left + action.right;
    context.log(&format!(
        "Add: {} + {} = {}",
        action.left, action.right, res
    ));
    HookResponse::entity(Sum::new(res))
}

// Generated by macro
pub fn create_add_action_handler() -> EventHandler {
    let handler: Pin<Box<HandlerFunction>> = Box::pin(add_action_executor);
    EventHandler::new(handler, "AddAction", "execute_add")
}

// Generated by macro
pub fn add_action_executor(
    dispatcher: &Flux,
    value: Arc<Payload>,
) -> Pin<Box<dyn Future<Output = HookResponse> + Send + Sync + '_>> {
    let context: &TestContext = dispatcher.get_context();
    let state: &FluxState = dispatcher.get_state();

    Box::pin(async move {
        // Simulate some work and return an RxResponse
        if let Ok(payload) = value.downcast::<AddAction>() {
            let p = payload.as_ref();
            let mut res = add_action(p, state, context).await;
            res.set_handler("execute_add");
            res
        }else {
            let mut res = HookResponse::error( "Action downcast error");
            res.set_handler("execute_add");
            res
        }
        
    })
}

pub struct TestContext {}

impl TestContext {
    pub fn log(&self, text: &str) {
        println!("Log: {}", text);
    }
}

#[async_trait]
// Generated by macro
impl FluxContext for TestContext {
    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_context(&self) -> &dyn FluxContext {
        self
    }

    async fn json_event(&self, dispatcher: &Flux, event: &Value) -> Vec<HookResponse> {
        if let Ok(action) = serde_json::from_value::<Sum>(event.clone()) {
            return dispatcher.push(action).await;
        }
        vec![]
    }

    fn get_hooks(&self) -> Vec<EventHandler> {
        vec![create_add_action_handler()]
    }

    fn query_entities(&self, state: &FluxState, query: &StateQuery) -> Vec<Value> {
        vec![]
    }

    fn get_entities(&self, state: &FluxState, query: &StateGetEntities) -> Vec<Value> {
        vec![]
    }
    
}

#[tokio::test]
pub async fn test_action_unfold() {
    let context = TestContext {};
    let dispatcher = Flux::new("test-data/out/flux-state-unfold", context);

    let add_action = AddAction::new(2, 3);

    let res = dispatcher.push(add_action).await;

    println!("Res : {:?}", res);
    println!("Res JSON : {:?}", serde_json::to_string(&res).unwrap());
}
