use std::{any::Any, future::Future, pin::Pin, sync::Arc};

use crate::{
    flux::{FluxContext, AxEvent, Flux, AxResponse, EventHandler, HandlerFunction},
    prelude::Payload,
};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug)]
pub struct AddAction {
    pub left: u16,
    pub right: u16,
}

// Generated by macro
impl AxEvent for AddAction {
    fn get_id(&self) -> &str {
        "000"
    }

    fn get_kind(&self) -> &str {
        "AddAction"
    }

    fn get_key(&self) -> String {
        format!("{}#{}", self.get_kind(), self.get_id())
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Sum {
    pub result: u16,
}

// Generated by macro
impl AxEvent for Sum {
    fn get_id(&self) -> &str {
        "000"
    }

    fn get_kind(&self) -> &str {
        "Sum"
    }

    fn get_key(&self) -> String {
        format!("{}#{}", self.get_kind(), self.get_id())
    }
}

pub async fn add_action(
    action: &AddAction,
    _dispatcher: &Flux,
    context: &TestContext,
) -> Result<Sum, String> {
    let res = action.left + action.right;
    context.log(&format!(
        "Add: {} + {} = {}",
        action.left, action.right, res
    ));
    Ok(Sum { result: res })
}

// Generated by macro
pub fn create_add_action_handler() -> EventHandler {
    let handler: Pin<Box<HandlerFunction>> = Box::pin(add_action_executor);
    EventHandler::new(handler, "AddAction", "execute_add")
}

// Generated by macro
pub fn add_action_executor(
    dispatcher: &Flux,
    value: Arc<Payload>,
) -> Pin<Box<dyn Future<Output = AxResponse> + Send + Sync + '_>> {
    let context: &TestContext = dispatcher.get_context();

    Box::pin(async move {
        // Simulate some work and return an RxResponse
        if let Ok(payload) = value.downcast::<AddAction>() {
            let p = payload.as_ref();
            let res = add_action(p, dispatcher, context).await;
            if let Ok(res) = res {
                return AxResponse {
                    success: true,
                    handler: "execute_add".to_string(),
                    value: Some(serde_json::to_value(res).unwrap()),
                };
            }
        }
        return AxResponse {
            success: false,
            handler: "execute_add".to_string(),
            value: None,
        };
    })
}

pub struct TestContext {}

impl TestContext {
    pub fn log(&self, text: &str) {
        println!("Log: {}", text);
    }
}

#[async_trait]
// Generated by macro
impl FluxContext for TestContext {
    
    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_context(&self) -> &dyn FluxContext {
        self
    }

    async fn json_event(&self, dispatcher: &Flux, event: &Value) -> Vec<AxResponse> {
        if let Ok(action) = serde_json::from_value::<Sum>(event.clone()) {
            return dispatcher.dispatch_event(action).await;
        }
        vec![]
    }

    fn get_hooks(&self) -> Vec<EventHandler> {
        vec![]
    }
}

#[tokio::test]
pub async fn test_action_unfold() {
    
    let context = TestContext {};
    let mut dispatcher = Flux::new(context);

    
    dispatcher.add_action_handlers(vec![create_add_action_handler()]);

    
    let add_action = AddAction { left: 2, right: 3 };
    
    let res = dispatcher.dispatch_event(add_action).await;

    println!("Res : {:?}", res);
    println!("Res JSON : {:?}", serde_json::to_string(&res).unwrap());
}